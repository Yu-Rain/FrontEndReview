====# 手写题
[TOC]

## 函数柯里化（实现 sum(1,2)(3)()）★★★

```js
function sum(...args1) {
	let x = 0;
	// 资料上没有加这个判断，是否有必要加这个判断？
  if (args1.length > 0) {
  		x = args1.reduce((prev, next) => {return prev+next;})
  }
  return function(...args2) {
    // 如果第二个（）内的参数为空，这样写会报语法错误。
    if (args2.length == 0) return x;
    
    return sum(x, ...args2)；
    // 原来的写法，我觉得再调用一次reduce多余，给改成了上面的写法，不知道我的写法有没有什么问题？
    // let y = args2.reduce((prev, next) => {return prev+next;})
    // return sum(x+y)
  }
}

console.log(sum(1,2,2,5)(7)()) // 17

```

------

## 实现 call() ★★

```js
Function.prototype.myCall = function (context, ...rest) {
  // context代表指定的调用函数的上下文；
  // this 代表调用myCall的上下文
  context.fn = this;

  let result = context.fn(...rest);
	// 删除指定上下文中的函数属性，避免污染指定上下文。
  delete context.fn;
  // 返回结果
  return result;
}


// test

let obj = {
  name: 'jack'
}

function test(arg1, arg2, arg3) {
  console.log(this.name)   // jack
  console.log(arg1, arg2, arg3);  // 1 2 3
}
test.myCall(obj, 1,2,3);

```
-----
## 实现 apply() ★★

```js

Function.prototype.myApply = function (context, args) {

  context.fn = this;

  let res;
  if (!args){
    res = context.fn();
  } else  {
	 // 是否要判断 args是数组或类数组类型呢？
    res = context.fn(...args)

  }
  // 资料上没有写删除，这里是应该删除的吧
  delete context.fn;
  return res;
}



// test
let obj = {
  name: 'jack'
}

function test(arg1, arg2, arg3) {
  console.log(this.name)   // jack
  console.log(arg1, arg2, arg3);  // 1 2 3
}

test.myApply(obj, [1,2,3]);

```
------
## 实现 bind() ★★

```js
Function.prototype.myBind = function (context, ...args) {
  context.fn = this; 
  return function (...args2) {
    const result = context.fn(...args, ...args2);
    delete context.fn;
    return result;
   }
}

// 测试
const test = {
  name: "fy",
  showName: function (last) {
    console.log(this.name + " is " + last);
  },
};
test.showName("handsome"); // fy is handsome
test.showName.bind({ name: "Mr.fy" })("handsome"); // Mr.fy is handsome
test.showName.myBind({ name: "Mr.fy" })("handsome"); // Mr.fy is handsome
```

-----

## 实现 jsonp ★★★
> 参考资料： [维基百科 JSONP](https://zh.wikipedia.org/wiki/JSONP)

### 什么是JSONP?

JSONP（JSON with Padding）是JSON格式的一种**“使用模式”**。
> Padding 是 填充的意思。
> 
> 一份JSON文件并不是一个JavaScript程序。为了让浏览器可以在 `<script>`元素运行，**从`src`里URL 回传的必须是 可执行的JavaScript**。
>
> 在JSONP的使用模式里，**该URL回传的是 由函数调用 包起来的动态生成JSON**，这就是JSONP的“填充（padding）”或是“前辍（prefix）”的由来。

### 作用是什么？(使用场景？)
可以绕开**同源策略**，但同时就会有**安全风险**

### 代码实现
```js
// 创建新的script元素
var newscript = document.createElement('script');

// 路径参数中callback代表要获取哪个函数
newscript.src = 'https://www.adb.com?callback=fn'

document.body.appendChild(newscript);
// newscript中获取到的函数。
function fn(data) {
  console.log(data);
}

```
------


## 实现 Promise ★★★
## 实现 Promise.all() ★★★
## 实现 Promise.race() ★
## 实现 EventEmitter 订阅监听模式 ★★
## setTimout 实现 setInterval ★
## 深拷贝 ★★★
## 数组拍平 ★★★
## 数组去重 ★★★
## 去除字符串首尾空格 ★


## 如何在不引入第三个中间变量的情况下，完成两个数字的交换。
方案1
```js
a = a + b;
b = a - b;
a = a - b;

```
方案2
```js
a = b - a;
b = b - a;
a = b + a;

```

> 方案1和2都有可能导致数字越界。


方案3： 位运算

任意数和0进行异或运算，都等于自己本身

```js
a = a ^ b;
b = a ^ b;  // 结合律 b = a ^ (b ^ b)。 相当于 b = a ^ 0 = a
a = a ^ b;  
// 结合律和交换律，此时右侧的 a = a ^ b, b = a
// 所以 a = a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b

```


