# 缓存
[TOC]

> https://juejin.cn/post/6844903757872889870
> https://juejin.cn/post/6844904153043435533
> [HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)

## 缓存类型
* 私有：浏览器缓存
* 共享：代理缓存，CDN等

只能缓存GET请求的响应内容。



## 浏览器缓存位置

### Service Worker

```
没有使用过，不是很了解。 主要是可以手动控制缓存。
```

* Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
* 使用 Service Worker的话，传输协议必须为 HTTPS

### Memory Cache

* 将当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等，放到内存中缓存
* 缓存在内存中，读取会很快；但同样的内存空间小，存储不了太多太大的资源。
* 一旦关闭浏览器页签页面，内存缓存资源所占用的空间就会被释放了。

### Disk Cache

* 存储在硬盘上的缓存。
* 相比Memory Cache， Disk Cache 可以存储更多更大的资源，存储时间也更长（需要手动清除），但读取速度相对会慢。
* 可以根据HTTP 头部字段判断
	* 哪些资源需要缓存
	* 哪些资源可以不请求直接使用
	* 哪些资源已经过期需要重新请求。 

#### Memory Cache & Disk Cache

• 对于大文件来说，大概率是不存储在内存中的，反之优先存储在内存中
• 当前系统内存使用率高的话，文件优先存储进硬盘


### Push Cache

```
没有使用过，不太了解
```

* Push Cache（推送缓存）是 HTTP/2 中的内容
* 当以上三种缓存都没有命中时，它才会被使用
* 它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂


> 如果资源都不在以上缓存中，那么就发起请求获取资源。


------

## 缓存策略


通过HTTP的请求和响应中的头部字段，设置缓存策略。

* 强缓存
	* 无需向服务器发送请求验证资源是否发生改变，直接从本地缓存中获取资源并使用
	* HTTP 状态码是200
* 协商缓存
	* 在使用缓存中的资源之前，需要先向服务器发起一个验证请求。
	* 如果验证通过会返回 304状态码 
	* 如果验证失败，服务器会返回新资源和200状态码，并更新验证标志。

### 强缓存

#### Expires

* HTTP 1.0标准
* 代表资源过期时间，绝对值。
* 客户端发送请求的时候，会使用客户端的时间和Expires字段的时间进行比较。小于就直接从缓存中获取资源，状态码依然是200 ok。
* 缺点： 
	* 客户端和服务器时间不同，造成误差

#### Cache-Control	

* HTTP 1.1标准
* 常用指令如下：
	* max-age: 缓存的有效时长
		* 单位为秒，是一种相对值，弥补了Expires绝对值的缺点
	* no-cache: 缓存但重新验证 （属于协商缓存）
		* 设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。 
		* 每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。 
	* no-store: 没有缓存
		* 缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。 
		
	* public: 可以被任意方缓存，比如中间的代理服务器。
	* private: 只能用于浏览器的私有缓存，不能被中间的代理服务器缓存
	
	举例：
	```js
	cache-control: public, max-age=86400
	```
	


### 协商缓存
如果没有设置强缓存，或者强缓存没有命中，又设置了以下Header字段，那么就会使用协商缓存

#### Etag / If-None-Match 

* Etag是服务器根据资源的内容生成的唯一标识，如果内容有改变，Etag的值就会变化 
* Etag会在响应头中被返回。 
* 之后的请求头中会携带If-None-Match, 它的值是上一次返回的响应头中的Etag值。 

* 服务器端根据接收到的If-None-Match进行对比。如果一致则返回304状态码，否则返回新资源，并修改Etag的值。       
      

#### Last-Modified / If-Modified-Since  
* Last-Modified 代表资源的最后修改时间，会在首次请求返回的响应头中。 
* 之后的请求头中会携带If-Modified-Since，它的值是上一次返回的Last-Modified的值 

* 服务器会根据If-Modified-Since和服务器端资源最后一次修改的时间作对比。如果一致则返回304状态码，否则返回新资源，并修改Last-Modified的值。 

#### 对比
* Etag的精度要大于 Last-Modified
	* Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。 
* Etag的性能要比Last-Modified差
	* Etag生成的过程会有额外的开销，影响服务器端的性能，不能完全代替Last-Modified.  

* Etag的优先级高于 Last-Modified 




## 项目中遇到的问题（不设置任何缓存策略）
在解决manifest.json文件缓存问题时得知的 

如果没有设置cach-control 和 expires的情况下， 但是设置了ETag （协商缓存）， 每次刷新（common+r) 依然是从 memory cache 或者 disk cache中获取资源文件，不会发起304请求。 

原因如下：https://segmentfault.com/q/1010000008955355 
```
如果没有Cache-Contorl和Expires的 header，但有Last-Modified，很多浏览器会这样计算 
(current time - last modified time) / 10 
RFC7234 
``` 

  
经过测试发现：https://juejin.cn/post/6844903725543194631#heading-6 
	•	common + r (称为soft refresh）会从 cache中读取文件  
	•	common + shift + R (称为 hard refresh） 会重新向服务器请求资源文件， 返回200状态码 
	◦	请求会加上一个Cache-Control:no-cache的标识来表明突破cache-control的限制， 







