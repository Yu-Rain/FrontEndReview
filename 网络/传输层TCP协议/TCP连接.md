TCP连接

> [Leetcode 传输层](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ek40dd/)

[TOC]

* TCP是传输层协议，为了方便通信，将HTTP请求报文按序号分成多个报文段，把每个报文段可靠的传给对方。

* 在握手之前，主动打开连接的客户端结束CLOSE阶段，被动打开的服务器结束CLOSE阶段，进入LISTEN阶段。

## 3次握手过程


### 第一次握手
**客户端向服务器发送SYN包**，并等待服务器确认。
其中：

* 标志位：**SYN**。
	* 表示请求建立连接
* 序号 ： **Seq=x** 。(x一般为1)
<!-- Seq序号用来验证服务器是否可以正常接收客户端发送的数据。 -->


发送完SYN包之后，**客户端进入SYN-SENT阶段**

### 第二次握手
服务器接收到SYN包，确认后结束LISTEN阶段，并返回一段TCP报文。
其中：

* 标志位： **SYN 和 ACK**。
	* 表示确认客户端的 报文Seq序号有效，服务器可以正常接收客户端发送的数据。
	* 并且同意创建新连接
* 序号  : **Seq=y**
* 确认号： **Ack=x+1**
	* 表示客户端的Seq序号加1作为 服务器的确认号Ack的值。返回给客户端
	
返回TCP报文后，**服务器进入SYN-RECV阶段**。	
<!-- 服务器把确认结果返回给 客户端。 ACK就代表同意连接 -->

### 第三次握手

客户端接收到SYN-ACK包，就知道从客户端到服务器的数据传输是正常的，就**结束了SYN-SENT阶段。**
返回最后一段报文：

* 标志位：**ACK**
	* 表示确认收到服务器同意连接的信号。
* 序 号：**Seq=x+1** 
	* 表示确认收到服务器的确认号Ack，并将其值作为自己的序号Seq的值。
* 确认号：**Ack=y+1** 
	* 表示确认收到服务器的序号Seq, 并将其值加1作为自己的确认号Ack的值 

<!-- 把服务器发来的报文内容，再返回去，告诉服务器我接收到你的信号 -->

返回报文后，客户端进入**ESTABLISHED阶段**

### 完成三次握手

当服务器接收到客户端返回的报文后，**得知从服务器到客户端的数据传输是正常的，从而结束SYN-RECV阶段，进入ESTABLISHED阶段，完成三次握手过程。**

------

### HTTPS的SSL协商

> TSL是以SSL为原型开发是协议，有时会统一称该协议为SSL。

如果是HTTPS协议，那么在TCP建立连接后，会开启SSL协商过程





### 如果三次握手的时候每次握手信息对方没有收到会怎么样？


* 第一次握手服务器没有接收到客户端发来的请求建立连接的数据包
	* 那么服务器不会有任何的返回。
	* 客户端在一段时间之后没有接收到服务器发来的确认报文，将重新发起建立连接的请求。
	* 如果服务器一直没有回应，客户端会重复第二步，一直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回-1。
	
* 第二次握手 客户端没有接收到服务器回应的ACK报文，会采取第一次握手失败的动作，一直重连到最大重传次数限制。
	* 而服务器端此时将阻塞在 accept()系统调用处等待 client 再次发送ACK报文 （就是服务器会一直等着客户端发送报文呗） 。

*  第三次握手 服务器没接到
	* 采取类似客户端的超时重传机制
	* 若重传次数超过限制后仍然没有回应，则 accep() 系统调用返回 -1, 服务器端连接建立失败
	* 但**此时客户端认为自己已经连接成功**了，因此开始向服务器端发送数据，
		* 但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 RST 报文给 客户端，**消除客户端单方面建立连接的状态**。
	
	
	> 个人总结：
	>  * 如果客户端或者服务器发出了请求，迟迟没有接收到回应，就会启动超时重传机制
	>  * 如果重传超出了最大限制，系统调用返回-1，结束当前阶段状态。
	>  * 但第三次握手失败后，服务器结束了监听状态，连接失败，但客户端认为连接成功，会正常发送请求。然后服务器会发送RST报文给客户端，消除客户端单方面建立连接的状态。
	
### Client 最大 TCP 连接数
client 在每次发起 TCP 连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口（local port），该端口是独占的，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 **65535**个。

### Server最大 TCP 连接数

server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此最大 TCP 连接为客户端 IP 数 × 客户端 port 数，对 IPV4，在不考虑 IP 地址分类的情况下，**最大 TCP 连接数约为 2 的 32 次方（IP 数）× 2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方**。

然而上面给出的是只是理论上的单机最大连接数，在实际环境中，受到明文规定（一些 IP 地址和端口具有特殊含义，没有对外开放）、机器资源、操作系统等的限制，特别是 sever 端，其最大并发 TCP 连接数远不能达到理论上限。对 server 端，通过增加内存、修改最大文件描述符个数等参数，**单机最大并发 TCP 连接数超过 10 万 是没问题的**。
	
### TCP 超时重传的原理
	
发送方在发送一次数据后就开启一个**定时器**，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个**复位信号**。

其中超时时间的计算是超时的核心，而定时时间的确定往往需要进行适当的权衡，因为当定时时间过长会造成**网络利用率不高**，定时太短会造成多次重传，使得**网络阻塞**。

在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间。

	
	-----------  

### 为什么需要3次握手，不能是2次？

3次握手是为了确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。

如果只有2次握手，那么客户端知道了服务器可以正常接收到自己发送的数据，但是服务器不知道客户端能不能收到自己发送的数据。



### 第 2 次握手传回了 ACK，为什么还要传回 SYN

ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了告诉客户端，服务端收到的消息确实是客户端发送的消息。

-----

## 4次挥手

TCP通过4次挥手释放连接。
假设客户端主动释放连接，结束ESTABLISHED阶段，随后开始4次挥手

### 第一次挥手

客户端向服务器发送 TCP 报文，表明想要释放TCP连接。
其中：

* 标志位：**FIN**
* 序号：**Seq = u**

客户端进入 **FIN-WAIT-1**阶段，停止向服务器发送数据。

### 第二次挥手
服务器接收到客户端发来的FIN请求后，返回一个ACK确认应答
其中：

* 标志位：**ACK**
* 序号：**Seq = v**
* 确认号：**Ack = u + 1**

服务器结束 ESTABLISHED 阶段，进入 **CLOSE-WAIT** 阶段

客户端在接收到ACK确认应答报文后，会**结束FIN-WAIT-1**阶段，进入**FIN-WAIT-2**阶段

### 第三次挥手

服务器在发送完ACK确认应答之后，会将遗留数据发送给客户端。等发送完成后，服务器做好了释放连接的准备，会再次向客户端发送TCP报文，其中：

* 标志位：**FIN和ACK**，代表已经准备好释放连接了。
* 序号：**Seq = w**
* 确认号：**Ack = u + 1**

随后服务器结束 CLOSE-WAIT阶段，**进入LAST-ACK阶段**，并停止向客户端发送请求。

### 第四次挥手
客户端接收到服务器发来的TCP报文，确认服务器已经做好了释放TCP连接的准备，结束FIN-WAIT-2阶段，**进入TIME-WATI阶段**， 并向服务器发送一段TCP报文，其中：

* 标志位： **ACK**，
* 序号： **Seq = u + 1**
* 确认号： **Ack = w + 1**


随后客户端开始在 TIME-WAIT 阶段**等待 2 MSL**。
服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此**正式确认关闭**
服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此**完成「四次挥手」**。



------


### 为什么要4次挥手？

主动发起释放TCP请求的一方为主动方。
在4次挥手过程中，要确认被动方是否还有必要的数据需要处理，等被动方做好释放TCP请求之后，在主动方再完全释放TCP连接。

### TIME-WAIT 为什么是 2MSL
当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。
若服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文。
如果**客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文**，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。

所以客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是**确认服务器能否接收到客户端发出的 ACK 确认报文**。


